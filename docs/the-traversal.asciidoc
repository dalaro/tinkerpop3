[[traversal]]
The Traversal
=============

image::gremlin-running.png[width=125]

At the most general level there is `Traversal<S,E>` which implements `Iterator<E>`, where the `S` stands for start and the `E` stands for end. A traversal is composed of four primary components:
  
 . `Step<S,E>`: an individual function applied to `S` to yield `E`.
 . `TraversalStrategy`: interceptor methods to alter the execution of the traversal.
 . `Traversal.SideEffects`: key/value pairs that can be used to store global information about the traversal.
 . `Traverser<T>`: the object propagating through the `Traversal` currently representing an object of type `T`. 

The classic notion of a graph traversal is provided by `GraphTraversal<S,E>` which extends `Traversal<S,E>`.

[[graph-traversal-steps]]
Graph Traversal Steps
---------------------

image::step-types.png[width=650]

A `GraphTraversal<S,E>` can be spawned off of a Graph, Vertex, or an Edge. A graph traversal is composed of an ordered list of steps. Each step is of particular general form as diagrammed above. A list of all the steps (and their descriptions) are provided in the TinkerPop3 link:http://www.tinkerpop.com/javadocs/x.y.z/core/com/tinkerpop/gremlin/process/graph/GraphTraversal.html[GraphTraversal JavaDoc]. A few of the more interesting/complex steps are presented in the following subsections.

[[lambda-steps]]
Lambda Steps
~~~~~~~~~~~~

There are four generic steps by which all other specific steps described later extend.

[width="100%",cols="10,12",options="header"]
|=========================================================
| Step| Description
| `map(Function<Traverser<S>, E>)` | map the traverser to some object of type `E` for the next step to process.
| `flatMap(Function<Traverser<S>, Iterator<E>>)` | map the traverser to an iterator of `E` objects that are streamed to the next step.
| `filter(Predicate<Traverser<S>>)` | map the traverser to either true or false, where false will not pass the traverser to the next step.
| `sideEffect(Consumer<Traverser<S>>)` | perform some operation on the traverser and pass it to the next step.
|=========================================================

The `Traverser<S>` object provides access to:

. The current traversed `S` object -- `Traverser.get()`.
. The current path traversed by the traverser -- `Traverser.path()`.
. The number of times the traverser has gone through a loop -- `Traverser.loops()`.
. The number of objects represented by this traverser -- `Traverser.bulk()`.
. The side-effects associated with the traversal -- `Traverser.sideEffects()`.
. A helper shorthand to get a particular side-effect -- `Traverser.get(String) == Traverser.sideEffects().get(String)`.

IMPORTANT: If a specific traversal step can do the necessary step-computation, use it. Lambda steps can not be optimized by the Gremlin <<traversalstrategy,traversal strategies>> and should only be used when the requisite computation does not have a corresponding standard Gremlin step. For example, instead of `filter{it.get().property('name').isPresent()}` use `has('name')`.

image:map-lambda.png[width=150,float=right]
[source,groovy]
gremlin> g.v(1).as('a').out() <1>
==>v[3]
==>v[2]
==>v[4]
gremlin> g.v(1).as('a').out().map{it.get('a')} <2>
==>v[1]
==>v[1]
==>v[1]
gremlin> g.v(1).as('a').out.back('a') <3>
==>v[1]
==>v[1]
==>v[1]

<1> A standard outgoing traversal from vertex 1.
<2> For each vertex outgoing adjacent to vertex 1, get the vertex at `a` (which is vertex 1).
<3> The <<back-step,`back()`>>-step is implemented as a `map()`-step that accesses side effects.

image:filter-lambda.png[width=160,float=right]
[source,groovy]
gremlin> g.V().filter{it.get().property('age').isPresent()} <1>
==>v[1]
==>v[2]
==>v[4]
==>v[6]
gremlin> g.V().has('age') <2>
==>v[1]
==>v[2]
==>v[4]
==>v[6]

<1> A filter that only allows the vertex to pass if it has an age property.
<2> The more specific `has()`-step is implemented as a `filter()` with respective predicate.


image:side-effect-lambda.png[width=175,float=right]
[source,groovy]
gremlin> g.V().has('age').sideEffect{println it} <1>
v[1]
==>v[1]
v[2]
==>v[2]
v[4]
==>v[4]
v[6]
==>v[6]

<1> Whatever enters sideEffect is passed to the next step, but some intervening process can occur.


[[addedge-step]]
AddEdge Step
~~~~~~~~~~~~

image::addedge-step.png[width=450]

link:http://en.wikipedia.org/wiki/Automated_reasoning[Reasoning] is the process of making explicit in the data was is implicit in the data. What is explicit in a graph are the objects of the graph -- i.e. vertices and edges. What is implicit in the graph is the traversal. In other words, traversals expose meaning where the meaning is defined by the traversal description. For example, take the concept of a "co-developer." Two people are co-developers if they have worked on the same project together. This concept can be represented as a traversal and thus, the concept of "co-developers" can be derived. This is made possible with `addE()`-step (*sideEffect*).

[source,groovy]
gremlin> g.v(1).as('a').out('created')
==>v[3]
gremlin> g.v(1).as('a').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.v(1).as('a').out('created').in('created').except('a') // marko can't be a co-developer with himself
==>v[4]
==>v[6]
gremlin> g.v(1).as('a').out('created').in('created').except('a').addBothE('co-developer','a')
==>v[4]
==>v[6]
gremlin> g.v(1).out('co-developer').values('name')
==>josh
==>peter
gremlin> g.v(1).out('co-developer').in('co-developer')
==>v[1]
==>v[1]

Note that it is possible to add an arbitrary number of key/value pairs (i.e. Object var args) to the `addE` steps to have those attached as properties to the created edges. 


[[aggregate-step]]
Aggregate Step
~~~~~~~~~~~~~~

image::aggregate-step.png[width=800]

The `aggregate()`-step (*sideEffect*) is used to aggregate all the objects at a particular point of traversal into a Collection. The step uses link:http://en.wikipedia.org/wiki/Eager_evaluation[eager evaluation] in that no objects continue on until all previous objects have been fully aggregated (as opposed to <<store-step,`store()`>> which link:http://en.wikipedia.org/wiki/Lazy_evaluation[lazily] fills a collection). The eager evaluation nature is crucial in situations where everything at a particular point is required for future computation. An example is provided below.

[source,groovy]
gremlin> g.v(1).out('created') // what has marko created?
==>v[3]
gremlin> g.v(1).out('created').aggregate('x') // aggregate all his creations
==>[v[3]]
gremlin> g.v(1).out('created').aggregate('x').in('created') // who are marko's collaborators
==>v[1]
==>v[4]
==>v[6]
gremlin> g.v(1).out('created').aggregate('x').in('created').out('created') // what have marko's collaborators created?
==>v[3]
==>v[5]
==>v[3]
==>v[3]
gremlin> g.v(1).out('created').aggregate('x').in('created').out('created').except('x').values('name') // what have marko's collaborators created that he hasn't created?
==>ripple

In link:http://en.wikipedia.org/wiki/Recommender_system[recommendation systems], the above pattern is used:
	
	"What has userA liked? Who else has liked those things? What have they liked that userA hasn't already liked?"


[[back-step]]
Back Step
~~~~~~~~~

link:http://en.wikipedia.org/wiki/Functional_programming[Functional languages] make use of function composition and lazy evaluation to create complex computations from primitive operations. This is exactly what Gremlin `GraphTraversal` does. One of the differentiating aspects of Gremlin's data flow approach to graph processing is that the flow need not always go "forward," but in fact, can go back to a previously seen area of computation. Examples include <<jump-step,`jump()`>> as well as the `back()`-step (*map*).

[source,groovy]
gremlin> g.V().out().out()
==>v[5]
==>v[3]
gremlin> g.V().out().out().path()
==>[v[1], v[4], v[5]]
==>[v[1], v[4], v[3]]
gremlin> g.V().as('x').out().out().back('x')
==>v[1]
==>v[1]
gremlin> g.V().out().as('x').out().back('x')
==>v[4]
==>v[4]
gremlin> g.V().out().out().as('x').back('x') // pointless
==>v[5]
==>v[3]

[[choose-step]]
Choose Step
~~~~~~~~~~~

The `choose()`-step (*branch*) allows for the current `Traverser<T>` to select which traversal branch to take. With `choose()`, it is possible to implement if/else-based semantics.

[source,groovy]
gremlin> g.V().has('age').values('name').map{[it.get(), it.get().length()]}
==>[marko, 5]
==>[vadas, 5]
==>[josh, 4]
==>[peter, 5]
gremlin> g.V().has('age').filter{it.get().value('name').length() == 5}.in().values('name')
==>marko
gremlin> g.V().has('age').filter{it.get().value('name').length() == 4}.out().values('name')
==>ripple
==>lop

Given the facts above, the following examples show how to use `choose()` to select the values.

image::choose-step.png[width=700]

[source,groovy]
gremlin> g.V().has('age').choose({it.get().value('name').length() == 5},   // If the predicate is true, then do `in`, else do `out`.
  g.of().in(),
  g.of().out()).values('name')
==>marko
==>ripple
==>lop
gremlin> g.V().has('age').choose({it.get().value('name').length()},   // Use the result of the function as a key to the map of traversal choices.
  [5:g.of().in(),
   4:g.of().out()]).values('name')
==>marko
==>ripple
==>lop

In Java8, there is no elegant syntax to create a `Map`. Thus, the last traversal above would look as follows:

[source,java]
g.V().has("age").choose(v -> v.get().value("name").length(), new HashMap() {{
  put(5,g.of().in());
  put(4,g.of().out());
}}).values("name")

[[cyclicpath-step]]
CyclicPath Step
~~~~~~~~~~~~~~~

image::cyclicpath-step.png[width=400]

Each traverser maintains its history through the traversal over the graph -- i.e. its <<path-data-structure,path>>. If it is important that the traverser repeat its course, then `cyclic()`-path should be used (*filter*). The step analyzes the path of the traverser thus far and if there are any repeats, the traverser is filtered out over the traversal computation. If non-cyclic behavior is desired, see <<simplepath-step,`simplePath()`>>.

[source,groovy]
gremlin> g.v(1).both().both()
==>v[1]  // back to v[1]
==>v[4]
==>v[6]
==>v[1]  // back to v[1]
==>v[5]
==>v[3]
==>v[1]  // back to v[1]
gremlin> g.v(1).both().both().cyclicPath()
==>v[1]
==>v[1]
==>v[1]
gremlin> g.v(1).both().both().cyclicPath().path()
==>[v[1], v[3], v[1]]
==>[v[1], v[2], v[1]]
==>[v[1], v[4], v[1]]

[[dedup-step]]
Dedup Step
~~~~~~~~~~

With `dedup()`-step (*filter*), repeatedly seen objects are removed from the traversal stream. Note that if a traverser's bulk is greater than 1, then it is set to 1 before being emitted.

[source,groovy]
gremlin> g.V().values('lang')
==>java
==>java
gremlin> g.V().values('lang').dedup()
==>java

If a lambda is provided to `dedup()`, then the object is processed by the lambda prior to determining if it has been seen or not.

[source,groovy]
gremlin> g.V().values('name').map{[it.get(), it.get().length()]}
==>[marko, 5]
==>[vadas, 5]
==>[lop, 3]
==>[josh, 4]
==>[ripple, 6]
==>[peter, 5]
gremlin> g.V().values('name').dedup{it.get().length()}
==>marko
==>lop
==>josh
==>ripple

WARNING: The `dedup()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal de-duplication only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. When `dedup()` is an end step, the resultant traversers are de-duplicated by `TraverserMapReduce`.

[[except-step]]
Except Step
~~~~~~~~~~~

The `except()`-step (*filter*) can be used to remove objects from the traversal stream. If `except()` is provided a string, then the excepting object is located at `traverser.sideEffects().get(label)`. If `except()` is provided a collection, then any object contained in that collection is filtered out. Please see the related <<retain-step,`retain()`>>-step.

[source,groovy]
gremlin> g.v(1).as('x').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.v(1).as('x').out('created').in('created').except('x') // co-developers
==>v[4]
==>v[6]
gremlin> g.v(1).as('x').out('created').in('created').values('name')
==>marko
==>josh
==>peter
gremlin> g.v(1).as('x').out('created').in('created').values('name').except(['marko','stephen'])
==>josh
==>peter

[[fold-step]]
Fold Step
~~~~~~~~~

There are situations when the traversal stream needs a "barrier" to aggregate all the objects and emit a computation that is a function of the aggregate. The `fold()`-step (*map*) is one particular instance of this. Please see <<unfold-step,`unfold()`>>-step for the inverse functionality.

[source,groovy]
gremlin> g.v(1).out('knows').values('name')
==>vadas
==>josh
gremlin> g.v(1).out('knows').values('name').fold() <1>
==>[vadas, josh]
gremlin> g.v(1).out('knows').values('name').fold(0){a,b -> a + b.get().length()} <2>
==>9

<1> A parameterless `fold()` will aggregate all the objects into a list and then emit the list.
<2> `fold()` can be provided two arguments --  a seed value and a reduce bi-function.

[[groupby-step]]
GroupBy Step
~~~~~~~~~~~~

As traversers propagate across a graph as defined by a traversal, sideEffect computations are sometimes required. That is, the actually path taken or the current location of a traverser is not the ultimate output of the computation, but some other representation of the traversal. The `groupBy()`-step (*sideEffect*) is one such sideEffect that organizes the objects according to some function of the object. Then, if required, that organization (a list) is reduced. An example is provided below.

[source,groovy]
gremlin> g.V().groupBy{it.get().value('name')[1]}   // group the vertices by the second letter of their name
==>[a:[v[1], v[2]], e:[v[6]], i:[v[5]], o:[v[3], v[4]]]
gremlin> g.V().groupBy{it.get().value('name')[1]}{it.get().value('name')}   // for each vertex in the group, get their name (now the name[1] is apparent)
==>[a:[marko, vadas], e:[peter], i:[ripple], o:[lop, josh]]
gremlin> g.V().groupBy{it.get().value('name')[1]}{it.get().value('name')}{it.size()}   // for each grouping, what is it's size?
==>[a:2, e:1, i:1, o:2]

The three lambda parameters of `groupBy` are discussed below.

. Key-lambda: What feature of the object to group on (a function that yields the map key)?
. Value-lambda: What feature of the group to store in the key-list?
. Reduce-lambda: What feature of the key-list to ultimately return?

WARNING: The `groupBy()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal grouping only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. However, `GroupByMapReduce` provides unified groups at the end of the traversal computation.

[[groupcount-step]]
GroupCount Step
~~~~~~~~~~~~~~~

When it is important to know how many times a particular object has been at a particular part of a traversal, `groupCount()`-step (*sideEffect*) is used.

	"What is the distribution of ages in the graph?"

[source,groovy]
gremlin> g.V().has('age').values('age').groupCount()
==>[32:1, 35:1, 27:1, 29:1]
gremlin> g.V().has('age').groupCount{it.get().value('age')} // you can also supply a pre-group lambda
==>[32:1, 35:1, 27:1, 29:1]

There is one person that is 32, one person that is 35, one person that is 27, and one person that is 29.

	"Iteratively walk the graph and count the number of times you see the second letter of each name."

image::groupcount-step.png[width=500]

[source,groovy]
gremlin> g.V().as('x').both().groupCount('m'){it.get().value('name')[1]}.jump('x',10).cap('m')
==>[a:19598, e:5740, i:5740, o:27716]

The above is interesting in that it demonstrates the use of referencing the internal `Map<Object,Long>` of `groupCount` with a string variable. Given that `groupCount` is a sideEffect-step, it simply passes the object it received to its output. Internal to `groupCount`, the object's count is incremented. If `groupCount` is the last step in the traversal, the `SideEffectCapStrategy` (see <<traversalstrategy,Traversal Strategy>>) automatically returns the internal map. However, if the `groupCount` is not the last step, then the sideEffect data structure (i.e. the internal map of `groupCount`) can be accessed with `cap`-step by referencing the desired variable.

WARNING: The `groupCount()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal grouping only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. However, `GroupCountMapReduce` provides unified groups at the end of the traversal computation.

[[has-step]]
Has Step
~~~~~~~~

image::has-step.png[width=670]

It is possible to filter vertices, edges, and vertex properties based on their properties using `has()`-step (*filter*).

[source,groovy]
gremlin> g.V().has('age')
==>v[1]
==>v[2]
==>v[4]
==>v[6]
gremlin> g.V().has('age').out().has('name',within,['vadas','josh'])
==>v[2]
==>v[4]
gremlin> g.V().has('age').out().has('name',within,['vadas','josh']).outE().has(label,'created')
==>e[10][4-created->5]
==>e[11][4-created->3]

There are accessors available in the `T` "tokens" class. They include `label`, `id`, `key`, and `value`. Thus, it is possible to use `has()`-step to also filter on these aspects of an element.

[[inject-step]]
Inject Step
~~~~~~~~~~~

image::inject-step.png[width=800]

One of the major features of TinkerPop3 is "injectable steps." This makes it possible to insert objects arbitrarily into a traversal stream. This is how <<jump-step,jump()>> is implemented. In general, `inject()`-step (*sideEffect*) exists and a few examples are provided below.

[source,groovy]
gremlin> g.v(4).out().values('name').inject('daniel')
==>ripple
==>lop
==>daniel
gremlin> g.v(4).out().values('name').inject('daniel').map{it.get().length()}
==>6
==>3
==>6
gremlin> g.v(4).out().values('name').inject('daniel').map{it.get().length()}.path()
==>[v[4], v[5], ripple, 6]
==>[v[4], v[3], lop, 3]
==>[daniel, 6]

In the last example above, note that the path starting with `daniel` is only of length 2. This is because the `daniel` string was inserted half-way in the traversal. Finally, a typical use case is provided below -- when the start of the traversal is not a graph object.

[source,groovy]
gremlin> g.of().inject(1,2)
==>1
==>2
gremlin> g.of().inject(1,2).map{it.get() + 1}
==>2
==>3
gremlin> g.of().inject(1,2).map{it.get() + 1}.map{g.v(it.get())}.values('name')
==>vadas
==>lop

[[interval-step]]
Interval Step
~~~~~~~~~~~~~

The `interval()`-step (*filter*) is similar to <<has-step,`has()`>>-step in that it filters elements according to their properties.

[source,groovy]
gremlin> g.V().interval('age',20,30)
==>v[1]
==>v[2]
gremlin> g.V().interval('age',20,30).values('age')
==>29
==>27
gremlin> g.V().has('age',gt,20).has('age',lte,30).values('age') // the equivalent expression using only has()
==>29
==>27

[[jump-step]]
Jump Step
~~~~~~~~~

TinkerPop3 introduces the `jump()`-step (*branch*). This step allows the propagating traverser object to jump to any arbitrary section of the `Traversal`. Typically, this is determined by means of a predicate. In particular, with `jump`, the Gremlin is no longer constrained to *do-while* semantics, but can as well support *while-do* (see link:http://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html[Java Documentation on While]). Below are some examples of `jump()` in action.

[source,groovy]
gremlin> g.v(1).as('a').out().jump('a'){it.loops()<2}.values('name') <1>
==>ripple
==>lop
gremlin> g.v(1).as('a').jump('b'){it.loops()>1}.out().jump('a').as('b').values('name') <2>
==>ripple
==>lop
gremlin> g.v(1).jump('a').out().out().out().as('a').values('name') <3>
==>marko

<1> do-while semantics as found in the classic `loop()`-step in TinkerPop2.
<2> while-do semantics as introduced in TinkerPop3. Jump to step `b` if loops greater than 1 else, `out` and jump back to `a` (see  <<until-step,`until()`>>).
<3> a non-predicate based jump where `out.out.out` is seen as inert code.

If a predetermined number of loops is known, it is possible to avoid the use of the jump-predicate.

[source,groovy]
gremlin> g.v(1).as('a').out().jump('a',2).values('name')
==>ripple
==>lop

The `jump()`-step also supports an "emit predicate." Whereby the traverser is split in two -- the traverser exits the code block as well as continues back within the code block.

[source,groovy]
gremlin> g.v(1).as('a').out().jump('a'){it.loops()<2}{true}.values('name')
==>lop
==>vadas
==>josh
==>ripple
==>lop

image::jump-step.png[width=500]

The first time through the jump-sequence, the vertices lop, vadas, and josh are seen. Given that the loops==0, then traverser jumps back to step `a`. However, because the emit-predicate is declared true, those vertices are emitted from jump-sequence. At step 2 (loops==1), the vertices traversed are ripple and lop (Josh's created projects, as lop and vadas have no out edges) and are also emitted. loops==1 now so the traverser jumps back to step `a`. As ripple and lop have no out edges there are no vertices to traverse. Given that the loops==2 now it wil fail the predicate. Therefore, the traverser has seen the vertices: lop, vadas, josh, ripple, and lop.

The `jump()`-step highlights one of the major benefits of `Traverser<T>` in TinkerPop3: the ability to take a traverser and place it anywhere in the Traversal step-sequence. Because a traverser maintains all the metadata associated with its particular walk, and no step maintains state information about a traverser, traversers can be arbitrarily relocated without ill-effects.

[[match-step]]
Match Step
~~~~~~~~~~

The `match()`-step (*map*) is introduced into TinkerPop3 to support a more link:http://en.wikipedia.org/wiki/Declarative_programming[declarative] form of link:http://en.wikipedia.org/wiki/Pattern_matching[pattern matching]. Similar constructs were available in previous TinkerPop versions via the `table()`-step, but that has since been removed in favor of the `match().select()`-pattern. With MatchStep in TinkerPop, a query optimizer similar to the link:http://www.knowledgefrominformation.com/2011/04/16/budget-match-cost-effective-subgraph-matching-on-large-networks/[budget match algorithm] builds and revises query plans on the fly, while a query is in progress. For very large graphs, where the developer is uncertain of the statistics of the graph (e.g. how many `knows`-edges vs. `worksFor`-edges exist in the graph), it is advantageous to use `match()`, as an optimal plan will be determined automatically.  Furthermore, some queries are much easier to express via `match()` than with single-path traversals.

	"Who created a project named 'lop' that was also created by someone who is 29 years old? Return the two creators."

image::match-step.png[width=500]

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('created').as('b'),
            g.of().as('b').has('name', 'lop'),
            g.of().as('b').in('created').as('c'),
            g.of().as('c').has('age', 29)).
          select(['a', 'c']){it.value('name')} 
==>[a:marko, c:marko]
==>[a:josh, c:marko]
==>[a:peter, c:marko]

Note that the above can also be more concisely written as below which demonstrates that imperative inner-traversals can be arbitrarily defined.

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('created').has('name', 'lop').as('b'),
            g.of().as('b').in('created').has('age', 29).as('c')).
          select(['a', 'c']){it.value('name')} 
==>[a:marko, c:marko]
==>[a:josh, c:marko]
==>[a:peter, c:marko]


MatchStep brings functionality similar to link:http://en.wikipedia.org/wiki/SPARQL[SPARQL] to Gremlin. Like SPARQL, MatchStep conjoins a set of patterns applied to a graph.  For example, the following traversal finds exactly those songs which Jerry Garcia has both sung and written (using the Grateful Dead graph distributed in the `data/` directory):  

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.loadGraphML('data/grateful-dead.xml')
==>null
gremlin> g.V().match('a',
            g.of().as('a').has('name', 'Garcia'),
            g.of().as('a').in('writtenBy').as('b'),
            g.of().as('a').in('sungBy').as('b')).select('b').values('name')
==>CREAM PUFF WAR
==>CRYPTICAL ENVELOPMENT

Among the features which differentiate `match()` from SPARQL are:

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('created').has('name','lop').as('b'), <1>
            g.of().as('b').in('created').has('age', 29).as('c'),
            g.of().as('c').out().jump('c',2)). <2>
           select('c').out('knows').dedup().values('name') <3>
==>vadas
==>josh

<1> *Patterns of arbitrary complexity*: `match()` is not restricted to triple patterns or property paths.
<2> *Recursion support*: `match()` supports the branch-based steps within a pattern, including `jump()`.
<3> *Imperative/declarative hybrid*: Pre and prior to a `match()`, it is possible to leverage classic Gremlin imperative.

To extend point #3, it is possible to support going from imperative, to declarative, to imperative, ad infinitum.

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('knows').as('b'),
            g.of().as('b').out('created').has('name','lop')).
          select('b').
          out('created').
          match('a',
            g.of().as('a').in('created').as('b'),
            g.of().as('b').out('knows').as('c')).
          select('c').values('name')
==>vadas
==>josh

Like all other steps in Gremlin, `match()` is a function and thus, `match()` within `match()` is a natural consequence of Gremlin's functional foundation (i.e. recursive matching).

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('knows').as('b'),
            g.of().as('b').out('created').has('name','lop'),
            g.of().as('b').match('x',
                g.of().as('x').out('created').as('y'),
                g.of().as('y').has('name','ripple')).select('y').as('c')).
            select(['a','c']){it.value('name')}
==>[a:marko, c:ripple]

WARNING: Currently, `match()` does not operate within a multi-JVM <<graphcomputer,GraphComputer>> OLAP environment. Future work includes a linearization <<traversalstrategy,TraversalStrategy>> for `match()`.

[[using-where-with-match]]
Using Where with Match
^^^^^^^^^^^^^^^^^^^^^^

Match is typically used in conjunction with both `select()` (demonstrated previously) and `where()` (presented here). A `where()` allows the user to further constrain the result set provided by `match()`.

[source,groovy]
gremlin> g.V().match('a',
            g.of().as('a').out('created').as('b'),
            g.of().as('b').in('created').as('c')).
              where('a', neq, 'c').
               select(['a','c']){it.value('name')}
==>[a:marko, c:josh]
==>[a:marko, c:peter]
==>[a:josh, c:marko]
==>[a:josh, c:peter]
==>[a:peter, c:marko]
==>[a:peter, c:josh]

The `where()`-step can take either a `BiPredicate` (first example below) or a `Traversal` (second example below). Using `MatchWhereStrategy`, `where()`-clauses can be automatically folded into `match()` and thus, subject to `match()`-steps budget-match algorithm.

[source,groovy]
gremlin> traversal = g.V().match('a',
            g.of().as('a').out('created').as('b'),
            g.of().as('b').in('created').as('c')).
              where(g.of().as('a').out('knows').as('c')). <1>
               select(['a','c']){it.value('name')}; null <2>
==>null
gremlin> traversal.toString()
==>[TinkerGraphStep(vertex), MatchStep, WhereStep, SelectStep] <3>
gremlin> traversal.getStrategies().apply()
==>null
gremlin> traversal.toString()
==>[TinkerGraphStep(vertex), MatchStep, SelectStep] <4>
gremlin> traversal <5>
==>[a:marko, c:josh] <6>

<1> A `where()`-step with a traversal containing variable bindings declared in `match()`.
<2> A useful trick to ensure that that the traversal is not iterated by Gremlin Console.
<3> The string representation of the traversal prior to its strategies being applied.
<4> The string representation of the traversal after the strategies have been applied (and thus, `where()` is folded into `match()`)
<5> The Gremlin Console will automatically iterate anything that is an iterator or is iterable.
<6> Both marko and josh are co-developers and marko knows josh.

[[order-step]]
Order Step
~~~~~~~~~~

When the objects of the traversal stream need to be sorted, `order()`-step (*map*) can be leveraged.

[source,groovy]
gremlin> g.V().values('name').order()
==>josh
==>lop
==>marko
==>peter
==>ripple
==>vadas
gremlin> g.V().values('name').order(decr)
==>vadas
==>ripple
==>peter
==>marko
==>lop
==>josh
gremlin> g.V().values('name').order{a,b -> a.get()[1] <=> b.get[1]} // order by the second letter
==>marko
==>vadas
==>peter
==>ripple
==>lop
==>josh

Note that `order()` takes a `Comparator` var args and thus, its possible to do secondary sorting. Secondary sorting is presented below along with the handy `Comparator.comparing()` method.

[source,groovy]
gremlin> import static java.util.Comparator.*
...
gremlin> g.V().values('name').order(comparing{it.get()[1]}) // order by the second letter
==>marko
==>vadas
==>peter
==>ripple
==>lop
==>josh
gremlin> g.V().values('name').order(comparing{it.get()[1]},comparing{it.get()[12]}) // order by second letter and if a tie, the third letter
==>vadas
==>marko
==>peter
==>ripple
==>lop
==>josh

[[orderby-step]]
OrderBy Step
~~~~~~~~~~~~

One of the most traversed objects in a traversal is an `Element`. An element can have properties associated with it (i.e. key/value pairs). In many situations, it is desirable to sort an element traversal stream according to a comparison of their properties. The `orderBy()`-step (*map*) exists to support this.

[source,groovy]
gremlin> g.V().map{it.get().value('name') + ' is ' + it.get()}
==>marko is v[1]
==>vadas is v[2]
==>lop is v[3]
==>josh is v[4]
==>ripple is v[5]
==>peter is v[6]
gremlin> g.V().orderBy('name').map{it.get().value('name') + ' is ' + it.get()}
==>josh is v[4]
==>lop is v[3]
==>marko is v[1]
==>peter is v[6]
==>ripple is v[5]
==>vadas is v[2]
gremlin> g.V().orderBy('name',decr).map{it.get().value('name') + ' is ' + it.get()}
==>vadas is v[2]
==>ripple is v[5]
==>peter is v[6]
==>marko is v[1]
==>lop is v[3]
==>josh is v[4]

IMPORTANT: The `orderBy()`-step allows the user to provide an arbitrary number of comparators for primary, secondary, etc. sorting. These comparators can be lambdas or they can be pre-defined enums (e.g. `Order.incr`). It is always best to use a pre-defined enum instead of a generic lambda as the underlying vendor may be able to optimize the execution when the comparator is inspectable.

[[path-step]]
Path Step
~~~~~~~~~

A traverser is transformed as it moves through a series of steps within a `Traversal`. The history of the traverser is realized by examining its path with `path()`-step (*map*).

image::path-step.png[width=650]

[source,groovy]
gremlin> g.V().out().out().values('name')
==>ripple
==>lop
gremlin> g.V().out().out().values('name').path()
==>[v[1], v[4], v[5], ripple]
==>[v[1], v[4], v[3], lop]

If edges are required in the path, then be sure to traverser those edges explicitly.

[source,groovy]
gremlin> g.V().outE().inV().outE().inV().path()
==>[v[1], e[8][1-knows->4], v[4], e[10][4-created->5], v[5]]
==>[v[1], e[8][1-knows->4], v[4], e[11][4-created->3], v[3]]

It is possible to provide a var args of lamdas to post-process the elements of the path in a round-robin fashion.

[source,groovy]
gremlin> g.V().out().out().path{it.value('name')}{it.value('age')}
==>[marko, 32, ripple]
==>[marko, 32, lop]

Finally, because of lambda post-processing, nothing prevents the lambda from triggering yet another traversal. In the traversal below, for each element of the path traversed thus far, if its a person (as determined by having an `age`-property), then get all of their creations, else if its a creation, get all the people that created it.

[source,groovy]
gremlin> g.V().out().out().path{
  it.choose({it.get().has('age').hasNext()}, 
    g.of().out('created').values('name'),
    g.of().in('created').values('name')).toList()}
==>[[lop], [ripple, lop], [josh]]
==>[[lop], [ripple, lop], [marko, josh, peter]]

WARNING: Generating path information is expensive as the history of the traverser is stored into a Java list. With numerous traversers, there are numerous lists. Moreover, in an OLAP <<graphcomputer,`GraphComputer`>> environment this becomes exceedingly prohibitive as there are traversers emanating from all vertices in the graph in parallel. In OLAP there are optimizations provided for traverser populations, but when paths are calculated (and each traverser is unique due to its history), then these optimizations are no longer possible.

[[path-data-structure]]
Path Data Structure
^^^^^^^^^^^^^^^^^^^

The `Path` data structure is an ordered list of objects, where each object is associated to a `Set<String>` of labels. An example is presented below to demonstrate both the `Path` API as well as how a traversal yields labeled paths.

image::path-data-structure.png[width=350]

[source,groovy]
gremlin> path = g.v(1).as('a').has('name').as('b').out('knows').out('created').as('c').has('name','ripple').values('name').as('d').identity().as('e').path().next()
==>[v[1], v[4], v[5], ripple]
gremlin> path.size()
==>4
gremlin> path.objects()
==>v[1]
==>v[4]
==>v[5]
==>ripple
gremlin> path.labels()
==>[a, b]
==>[]
==>[c]
==>[d, e]
gremlin> path.a
==>v[1]
gremlin> path.b
==>v[1]
gremlin> path.c
==>v[5]
gremlin> path.d == path.e
==>true

[[profile-step]]
Profile Step
~~~~~~~~~~~~

The `profile()`-step (*sideEffect*) exists to allow developers to profile their traversals to determine statistical information like step runtime, counts, etc. The `profile()`-step can only be used if the system property `tinkerpop.profiling` is set to `true`. Thus, prior to starting the Gremlin Console, set `JAVA_OPTIONS` accordingly.

WARNING: When profiling is enabled, traversals are more costly to execute. Thus, be sure to not have `tinkerpop.profiling` set to `true` in any production or query time critical application. The best way to determine if profiling is enabled is to see if an `IllegalArgumentException` is thrown when the `profile()` step is used. If there is no exception, then profiling is enabled.

[source,groovy]
----
$ JAVA_OPTIONS=-Dtinkerpop.profiling=true
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.tinkergraph
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().out().out().profile()
==>Traversal Metrics
                            Step       Count Traversers       Time (ms)   % Dur
         TinkerGraphStep(vertex)           6          6           0.020    1.62
          VertexStep(OUT,vertex)           6          6           1.165   94.10
          VertexStep(OUT,vertex)           2          2           0.032    2.58
                     ProfileStep           2          2           0.004    0.32
               SideEffectCapStep           1          1           0.017    1.37
                           TOTAL           -          -           1.238       -
gremlin>
----

The `profile()`-step generates a `TraversalMetrics` object that contains the following information:

* `Step`: A step within the traversal being profiled.
* `Count`: The number of _represented_ traversers that passed through the step.
* `Traversers`: The number of traversers that passed through the step.
* `Time (ms)`: The total time the step was actively executing its behavior.
* `% Dur`: The percentage of total time spent in the step.

image:gremlin-exercise.png[width=120,float=left] It is important to understand the difference between `Count` and `Traversers`. Traversers can be "bulked" and as such, when two traversers are "the same" they may be aggregated into a single traverser. That new traverser has a `Traverser.bulk()` that is the sum of the two merged traverser bulks. On the other hand, the `Count` represents the sum of all `Traverser.bulk()` results and thus, expresses the number of "represented" (not enumerated) traversers. `Traversers` will always be less than or equal to `Count`.

If `-Dtinkerpop.profiling=true` is not set, then the following exception occurs.

[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.tinkergraph
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().out().out().profile()
The profile()-step can only be used when profiling is enabled via 'gremlin.sh -p' or directly via -Dtinkerpop.profiling=true
Display stack trace? [yN]
gremlin>
----

TIP: It is possible to enabled profiling for a Gremlin Console session via `gremlin.sh -p`.

[[random-step]]
Random Step
~~~~~~~~~~~

To randomly filter out a traverser, use `random()`-step (*filter*). The provided double argument biases the "coin toss."

[source,groovy]
gremlin> g.V().random(0.5)
==>v[2]
==>v[3]
gremlin> g.V().random(0.0)
gremlin> g.V().random(1.0)
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]

[[range-step]]
Range Step
~~~~~~~~~~

As traversers propagate through the traversal, it is possible to only allow a certain number of them to pass through with `range()`-step (*filter*). When the low-end of the range is not met, objects are continued to be iterated. When within the low and high range (both inclusive), traversers are emitted. Finally, when above the high range, the traversal breaks out of iteration.

[source,groovy]
gremlin> g.V().range(0,3)
==>v[1]
==>v[2]
==>v[3]
==>v[4]
gremlin> g.V().range(1,3)
==>v[2]
==>v[3]
==>v[4]
gremlin> g.V().as('a').both().jump('a',1000000).range(6,10)
==>v[1]
==>v[1]
==>v[1]
==>v[1]
==>v[1]

[[retain-step]]
Retain Step
~~~~~~~~~~~

The `retain()`-step (*filter*) can be used to filter objects from the traversal stream that don't match the provided criteria. If `retain()` is provided a string, the retaining object is retrieved via `traverser.sideEffects().get(label)`. If `retain()` is provided a collection, then any object not contained in that collection is filtered out. Please see the related <<except-step,`except()`>>-step.

[source,groovy]
gremlin> g.v(1).as('x').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.v(1).as('x').out('created').in('created').retain('x')
==>v[1]
gremlin> g.v(1).as('x').out('created').in('created').values('name')
==>marko
==>josh
==>peter
gremlin> g.v(1).as('x').out('created').in('created').values('name').retain(['marko','stephen'])
==>marko

[[select-step]]
Select Step
~~~~~~~~~~~

There are two use cases for `select()`-step (*map*).

. Select labeled steps within a path (as defined by `as()` in a traversal).
. Select objects out of a `Map<String,Object>` flow (i.e. a sub-map).

The first use case is demonstrated via example below.

[source,groovy]
gremlin> g.V().as('a').out().as('b').out().as('c') // no select
==>v[5]
==>v[3]
gremlin> g.V().as('a').out().as('b').out().as('c').select()
==>[a:v[1], b:v[4], c:v[5]]
==>[a:v[1], b:v[4], c:v[3]]
gremlin> g.V().as('a').out().as('b').out().as('c').select(['a','b'])
==>[a:v[1], b:v[4]]
==>[a:v[1], b:v[4]]
gremlin> g.V().as('a').out().as('b').out().as('c').select(['a','b']){it.value('name')}
==>[a:marko, b:josh]
==>[a:marko, b:josh]
gremlin> g.V().as('a').out().as('b').out().as('c').select('a') // if the selection is one step, no map is returned
==>v[1]
==>v[1]

The second use case is best understood in terms of <<match-step,`match()`>>-step where the result of `match()` is a `Map<String,Object>` of variable bindings. However, any step that emits a `Map<String,Object>` can be selected. A contrived example is presented below.

[source,groovy]
gremlin> g.V()[0..1].as('a').map{[b:1,c:2]} <1>
==>[b:1, c:2]
==>[b:1, c:2]
gremlin> g.V()[0..1].as('a').map{[b:1,c:2]}.select() <2>
==>[a:v[1], b:1, c:2]
==>[a:v[2], b:1, c:2]
gremlin> g.V()[0..1].as('a').map{[b:1,c:2]}.select(['a','c']) <3>
==>[a:v[1], c:2]
==>[a:v[2], c:2]
gremlin> g.V()[0..1].as('a').map{[b:1,c:2]}.select('c') <4>
==>2
==>2

<1> A contrived example to create a `Map<String,Object>` flow as a foundation for the examples to follow.
<2> Select will grab both labeled steps and `Map<String,Object>` entries.
<3> The same `List<String>` selectivity can be used as demonstrated in the previous example.
<4> If a single selection is used, then the object is emitted not wrapped in a map. Useful for continuing the traversal process without having to do a map projection.

[[using-where-with-select]]
Using Where with Select
^^^^^^^^^^^^^^^^^^^^^^^

Finally, like <<match-step,`match()`>>-step, it is possible to use `where()`, as where is a filter that processes `Map<String,Object>` streams.

[source,groovy]
gremlin> g.V().as('a').out('created').in('created').as('b').select{it.value('name')} <1>
==>[a:marko, b:marko]
==>[a:marko, b:josh]
==>[a:marko, b:peter]
==>[a:josh, b:josh]
==>[a:josh, b:marko]
==>[a:josh, b:josh]
==>[a:josh, b:peter]
==>[a:peter, b:marko]
==>[a:peter, b:josh]
==>[a:peter, b:peter]
gremlin> g.V().as('a').out('created').in('created').as('b').
           select{it.value('name')}.
             where('a',neq,'b') <2>
==>[a:marko, b:josh]
==>[a:marko, b:peter]
==>[a:josh, b:marko]
==>[a:josh, b:peter]
==>[a:peter, b:marko]
==>[a:peter, b:josh]
gremlin> g.V().as('a').out('created').in('created').as('b').select(). <3>
              where('a',neq,'b').
              where(g.of().as('a').out('knows').as('b')).
                select{it.value('name')}
==>[a:marko, b:josh]

<1> A standard `select()` that generates a `Map<String,Object>` of variables bindings in the path (i.e. `a` and `b`) for the sake of a running example.
<2> The `select{it.value('name')}` projects each binding vertex to their name property value and `where()` operates to ensure respective `a` and `b` strings are not the same.
<3> The first `select()` projects a vertex binding set. A binding is filtered if `a` vertex equals `b` vertex. A binding is filtered if `a` doesn't know `b`. The second and final `select()` projects the name of the vertices.

[[shuffle-step]]
Shuffle Step
~~~~~~~~~~~~

Randomizing the order of the traversers at a particular point in the traversal is possible with `shuffle()`-step (*map*).

[source,groovy]
gremlin> g.of().inject(1,2,3).map{it.get() * 2}
==>2
==>4
==>6
gremlin> g.of().inject(1,2,3).map{it.get() * 2}.shuffle()
==>4
==>6
==>2
gremlin> g.of().inject(1,2,3).map{it.get() * 2}.shuffle()
==>6
==>4
==>2

[[simplepath-step]]
SimplePath Step
~~~~~~~~~~~~~~~

image::simplepath-step.png[width=400]

When it is important that a traverser not repeat its path through the graph, `simplePath()`-step should be used (*filter*). The <<path-data-structure,path>> information of the traverser is analyzed and if the path has repeated objects in it, the traverser is filtered. If cyclic behavior is desired, see <<cyclicpath-step,`cyclicPath()`>>.

[source,groovy]
gremlin> g.v(1).both().both()
==>v[1]   // back to v[1]
==>v[4]
==>v[6]
==>v[1]   // back to v[1]
==>v[5]
==>v[3]
==>v[1]   // back to v[1]
gremlin> g.v(1).both().both().simplePath()
==>v[4]
==>v[6]
==>v[5]
==>v[3]
gremlin> g.v(1).both().both().simplePath().path()
==>[v[1], v[3], v[4]]
==>[v[1], v[3], v[6]]
==>[v[1], v[4], v[5]]
==>[v[1], v[4], v[3]]

[[store-step]]
Store Step
~~~~~~~~~~

When link:http://en.wikipedia.org/wiki/Lazy_evaluation[lazy] aggregation is needed, `store()`-step (*sideEffect*) should be used over <<aggregate-step,`aggregate()`>>. The two steps differ in that `store()` does not block and only stores objects in its side-effect collection as they pass through.

[source,groovy]
gremlin> g.V().aggregate('x').range(0,1).cap('x')
==>[v[1], v[2], v[3], v[4], v[5], v[6]]
gremlin> g.V().store('x').range(0,1).cap('x')
==>[v[1], v[2], v[3]]

It is interesting to note that there are three results in the `store()` side-effect even though the interval selection is for 2 objects. Realize that when the third object is on its way to the `range()` filter (i.e. `[0..1]`), it passes through `store()` and thus, stored before filtered.

[[subgraph-step]]
Subgraph Step
~~~~~~~~~~~~~

Extracting a portion of a graph from a larger one for analysis, visualization or other purposes is a fairly common use case for graph analysts and developers. The `subgraph()`-step (*sideEffect*) provides a way to produce an edge-induced subgraph from virtually any traversal.  The following code shows how to produce the "knows" subgraph:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = TinkerGraph.open() <1>
==>tinkergraph[vertices:0 edges:0]
gremlin> g.E().with('sg',sg).subgraph('sg', {it.label == 'knows'}) <2>
==>tinkergraph[vertices:3 edges:2]
gremlin> sg.E() <3>
==>e[7][1-knows->2]
==>e[8][1-knows->4]
----

<1> The empty graph to which the subgraph will be generated.
<2> As this function produces "edge-induced" subgraphs, the traversal must contain edges in the path.  Those edges found in that path are evaluated by a `Predicate` function to determine if they should be copied to the subgraph in conjunction with their associated vertices.
<3> The subgraph contains only "knows" edges.

A more common subgraphing use case is to get all of the graph structure surrounding a single vertex:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = g.v(3).as('a').inE().outV().jump('a'){it.loops()<3}{true}.subgraph({true}).next()   <1>
==>tinkergraph[vertices:4 edges:4]
gremlin> sg.E()
==>e[8][1-knows->4]
==>e[9][1-created->3]
==>e[11][4-created->3]
==>e[12][6-created->3]
----

<1> Starting at vertex `3`, traverse 3 steps away on in-edges, outputting all of that into the subgraph. Note that if now graph is provided, a `TinkerGraph` is assumed.

[[timelimit-step]]
TimeLimit Step
~~~~~~~~~~~~~~

In many situations, a graph traversal is not about getting an exact answer as its about getting a relative ranking. A classic example is link:http://en.wikipedia.org/wiki/Recommender_system[recommendation]. What is desired is a relative ranking of vertices, not their absolute rank. Next, it may be desirable to have the traversal execute for no more than 750 milliseconds. In such situations, `timeLimit()`-step (*filter*) can be used.

NOTE: The method `clock(int runs, Closure code)` is a utility preloaded in the <<gremlin-console,Gremlin Console>> that can be used to time execution of a body of code.

image::timelimit-step.png[width=500]

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().as('x').both().groupCount('m').jump('x',16).cap('m').next().sort{-it.value}
==>v[1]=2744208
==>v[3]=2744208
==>v[4]=2744208
==>v[2]=1136688
==>v[5]=1136688
==>v[6]=1136688
gremlin> clock(1){g.V().as('x').both().groupCount('m').jump('x',16).cap('m').next().sort{-it.value}}
==>2735.111
gremlin> g.V().as('x').timeLimit(750).both().groupCount('m').jump('x',16).cap('m').next().sort{-it.value}
==>v[1]=648473
==>v[3]=647510
==>v[4]=647499
==>v[5]=268540
==>v[6]=268533
==>v[2]=267941
gremlin> clock(1){g.V().as('x').timeLimit(750).both().groupCount('m').jump('x',16).cap('m').next().sort{-it.value}}
==>750.03

In essence, the relative order is respected, even through the number traversers at each vertex is not. The primary benefit being that the calculation is guaranteed to complete at the specified time limit (in milliseconds). Finally, note that the internal clock of `timeLimit()`-step starts when the first traverser enters it. When the time limit is reached, any `next()` evaluation of the step will yield a `NoSuchElementException` and any `hasNext()` evaluation will yield `false`.

[[tree-step]]
Tree Step
~~~~~~~~~

From any one element (i.e. vertex or edge), the emanating paths from that element can be aggregated to form a link:http://en.wikipedia.org/wiki/Tree_(data_structure)[tree]. Gremlin provides `tree()`-step (*sideEffect*) for such this situation.

image::tree-step.png[width=450]

[source,groovy]
gremlin> tree = g.V().out().out().tree().next()
==>v[1]={v[4]={v[3]={}, v[5]={}}}

It is important to see how the paths of all the emanating traversers are united to form the tree.

image::tree-step2.png[width=500]

The resultant tree data structure can then be manipulated (see link:http://www.tinkerpop.com/javadocs/current/com/tinkerpop/gremlin/process/graph/step/util/Tree.html[Tree JavaDoc]). For the sake of demonstration, a post-processing lambda is applied in the running example below.

[source,groovy]
gremlin> tree = g.V().out().out().tree{it.value('name')}.next()
==>marko={josh={ripple={}, lop={}}}
gremlin> tree['marko']
==>josh={ripple={}, lop={}}
gremlin> tree['marko']['josh']
==>ripple={}
==>lop={}
gremlin> tree.getObjectsAtDepth(3)
==>ripple
==>lop

[[unfold-step]]
Unfold Step
~~~~~~~~~~~

If the object reaching `unfold()` (*flatMap*) is an iterator, iterable, or map, then it is unrolled into a linear form. If not, then the object is simply emitted. Please see <<fold-step,`fold()`>>-step for the inverse behavior.

[source,groovy]
gremlin> g.v(1).out().fold().inject('gremlin',[1.23,2.34])
==>gremlin
==>[1.23, 2.34]
==>[v[3], v[2], v[4]]
gremlin> g.v(1).out().fold().inject('gremlin',[1.23,2.34]).unfold()
==>gremlin
==>1.23
==>2.34
==>v[3]
==>v[2]
==>v[4]

Note that `unfold()` does not recursively unroll iterators. Instead, `jump()` can be used to for recursive unrolling.

[source,groovy]
gremlin> g.of().inject(1,[2,3,[4,5,[6]]])
==>1
==>[2, 3, [4, 5, [6]]]
gremlin> g.of().inject(1,[2,3,[4,5,[6]]]).unfold()
==>1
==>2
==>3
==>[4, 5, [6]]
gremlin> g.of().inject(1,[2,3,[4,5,[6]]]).as('x').unfold().jump('x'){it.get() instanceof List}
==>1
==>2
==>3
==>4
==>5
==>6

[[union-step]]
Union Step
~~~~~~~~~~

image::union-step.png[width=650]

The `union()`-step (*branch*) supports the merging of the results of an arbitrary number of traversals. When a traverser reaches a `union()`-step, it is copied to each of its internal steps. The traverses emitted from `union()` are the outputs of the respective internal traversals.

[source,groovy]
gremlin> g.v(4).union(
            g.of().in().values('age'),
            g.of().out().values('lang'))
==>29
==>java
==>java
gremlin> g.v(4).union(
            g.of().in().values('age'),
            g.of().out().values('lang')).path()
==>[v[4], v[1], 29]
==>[v[4], v[5], java]
==>[v[4], v[3], java]

[[until-step]]
Until Step
~~~~~~~~~~

Gremlin provides *while-do* looping. This was demonstrated in the <<jump-step,Jump Step>> section of the documentation. However, when only using `jump()` for *while-do*, the representation can be confusing as there are numerous `jump` constructions. For the sake of simplicity, `until()`-step exists (*branch*).

[source,groovy]
gremlin> g.v(1).as('a').jump('b'){it.loops() > 1}.out().jump('a').as('b').values('name') <1>
==>ripple
==>lop
gremlin> g.v(1).until('b'){it.loops() > 1}.out().as('b').values('name') <2>
==>ripple
==>lop

<1> *while-do* looping using `jump()-step`.
<2> *while-do* looping using `until()-step`.

The `until()` expression in the example above states:
. Get the vertex with id 1 from the graph.
. Until the current traverser has loop'd two times, get the outgoing adjacent vertices of the current vertex of the traverser.
. When the traverser has loop'd two times, break out of the until-clause and then get the `name` of the current vertex of the traverser.


NOTE: The `until()`-step is not a "real" step. It is simply a marker that exist in the traversal. When the `UntilStrategy` is executed (see <<traversalstrategy,TraversalStrategy>>), the traversal is re-written by inserting `jump()`-steps accordingly. Thus, in the example above, the second traversal example using `until()` compiles to the first which uses `jump()`.

[[valuemap-step]]
ValueMap Step
~~~~~~~~~~~~~

The `valueMap()`-step yields a Map representation of the properties of an element.

[source,groovy]
gremlin> g.V().valueMap()
==>[name:[marko], age:[29]]
==>[name:[vadas], age:[27]]
==>[name:[lop], lang:[java]]
==>[name:[josh], age:[32]]
==>[name:[ripple], lang:[java]]
==>[name:[peter], age:[35]]
gremlin> g.V().valueMap('age')
==>[age:[29]]
==>[age:[27]]
==>[:]
==>[age:[32]]
==>[:]
==>[age:[35]]
gremlin> g.V().valueMap('age','blah')
==>[age:[29]]
==>[age:[27]]
==>[:]
==>[age:[32]]
==>[:]
==>[age:[35]]
gremlin> g.E().valueMap()
==>[weight:0.5]
==>[weight:1.0]
==>[weight:0.4]
==>[weight:1.0]
==>[weight:0.4]
==>[weight:0.2]

It is important to note that the map of a vertex maintains a list of values for each key. The map of an edge or vertex-property represents a single property (not a list). The reason is that vertices in TinkerPop3 leverage <<vertex-properties,vertex properties>> which are support multiple values per key. Using the <<the-crew-toy-graph,"The Crew">> toy graph, the point is made explicit.

[source,groovy]
gremlin> g = TinkerFactory.createTheCrew()
==>tinkergraph[vertices:6 edges:14]
gremlin> g.V().valueMap()
==>[name:[marko], location:[san diego, santa cruz, brussels, santa fe]]
==>[name:[stephen], location:[centreville, dulles, purcellville]]
==>[name:[matthias], location:[bremen, baltimore, oakland, seattle]]
==>[name:[daniel], location:[spremberg, kaiserslautern, aachen]]
==>[name:[gremlin]]
==>[name:[tinkergraph]]
gremlin> g.V().has('name','marko').properties('location')
==>vp[location->san diego]
==>vp[location->santa cruz]
==>vp[location->brussels]
==>vp[location->santa fe]
gremlin> g.V().has('name','marko').properties('location').valueMap()
==>[startTime:1997, endTime:2001]
==>[startTime:2001, endTime:2004]
==>[startTime:2004, endTime:2005]
==>[startTime:2005]

[[vertex-steps]]
Vertex Steps
~~~~~~~~~~~~

image::vertex-steps.png[width=350]

The vertex steps (*flatMap*) are fundamental to the Gremlin language and are perhaps the only "graph oriented" steps. Via these steps, its possible to "move" on the graph -- i.e. traverser.

* `out(integer, string...)`: Move to the outgoing adjacent vertices given the branch factor and edge labels.
* `in(integer, string...)`: Move to the incoming adjacent vertices given the branch factor and edge labels.
* `both(integer, string...)`: Move to both the incoming and outgoing adjacent vertices given the branch factor and edge labels.
* `outE(integer, string...)`: Move to the outgoing incident edges given the branch factor and edge labels.
* `inE(integer, string...)`: Move to the incoming incident edges given the branch factor and edge labels.
* `bothE(integer, string...)`: Move to both the incoming and outgoing incident edges given the branch factor and edge labels.
* `outV()`: Move to the outgoing vertex.
* `inV()`: Move to the incoming vertex.
* `bothV()`: Move to both vertices.
* `otherV()` : Move to the vertex that was not the vertex that was moved from.

[source,groovy]
gremlin> g.v(4)
==>v[4]
gremlin> g.v(4).outE()  // all outgoing edges
==>e[10][4-created->5]
==>e[11][4-created->3]
gremlin> g.v(4).outE(1)  // at most one outgoing edge per incoming vertex
==>e[10][4-created->5]
gremlin> g.v(4).inE('knows')  // all incoming knows-edges
==>e[8][1-knows->4]
gremlin> g.v(4).inE('created') // all incoming created-edges
gremlin> g.v(4).bothE('knows','created','blah')
==>e[10][4-created->5]
==>e[11][4-created->3]
==>e[8][1-knows->4]
gremlin> g.v(4).bothE('knows','created','blah').otherV()
==>v[5]
==>v[3]
==>v[1]
gremlin> g.v(4).both('knows','created','blah')
==>v[5]
==>v[3]
==>v[1]
gremlin> g.v(4).outE().inV() // moving forward touching edges,vertices
==>v[5]
==>v[3]
gremlin> g.v(4).out()  // moving forward only touching vertices
==>v[5]
==>v[3]
gremlin> g.v(4).inE().outV()
==>v[1]
gremlin> g.v(4).inE().bothV()
==>v[1]
==>v[4]

[[with-step]]
With Step
~~~~~~~~~

Traversal side-effects can be declared using `with()`-step (*sideEffect*). This will ensure that the default data structures used by the various sideEffects are ignored in favor of user supplied structures.

[source,groovy]
gremlin> g.V.both.name.store('x')
==>{lop=3, vadas=1, josh=3, marko=3, peter=1, ripple=1}   // the default is a BulkSet which is a weighted set
gremlin> g.V.with('x'){[] as Set}.both.name.store('x')
==>[lop, vadas, josh, marko, peter, ripple]
gremlin> g.V.with('x'){['stephen'] as Set}.both.name.store('x')
==>[stephen, lop, vadas, josh, marko, peter, ripple]

[[traversalstrategy]]
TraversalStrategy
-----------------

image:traversal-strategy.png[width=125,float=right] A `TraversalStrategy` can analyze a `Traversal` and mutate the traversal as it deems fit. This is useful in two situations:

 * There is a more efficient way to express the traversal at the TinkerPop3 level.
 * There is a more efficient way to express the traversal at the graph vendor level.

A simple TraversalStrategy is the `IdentityRemovalStrategy` and it is a type-1 strategy defined as follows:

[source,java]
public class IdentityRemovalStrategy implements TraversalStrategy.NoDependencies {
    public void apply(final Traversal traversal, final TraversalEngine traversalEngine) {
        traversal.getSteps().stream()
                .filter(step -> step instanceof IdentityStep
                    && !TraversalHelper.isLabeled(step))
                .collect(Collectors.<Step>toList())
                .forEach(step -> TraversalHelper.removeStep(step, traversal));
    }
}

This strategy simply removes any unlabeled `IdentityStep` steps in the Traversal as `aStep().identity().identity().bStep()` is equivalent to `aStep().bStep()`. The `NoDepedencies` interface is a marker interface that states that this strategy does not require the execution of another strategy before or after it. For those that do have dependencies, TraversalStrategy implements Comparable<TraversalStrategy> to allow a sort order of strategies prior to their evaluation.

[source,groovy]
gremlin> t = g.V().identity().identity().out(); null
==>null
gremlin> t.toString()
==>[TinkerGraphStep, IdentityStep, IdentityStep, VertexStep(OUT)]
gremlin> t.getStrategies().apply()         // never required by the user (automatically executed prior to evaluation)
==>null
gremlin> t.toString()
==>[TinkerGraphStep, VertexStep(OUT)]

Type-2 strategies are defined by graph vendors who implement TinkerPop3.

[source,groovy]
g.V().has('name','marko')

The expression above can be executed in a `O(|V|)` or `O(log(|V|)` fashion in <<tinkergraph-gremlin,TinkerGraph>> depending on whether there is or is not an index defined for "name."

[source,java]
TinkerGraphStepStrategy implements TraversalStrategy.NoDependency {
    public void apply(final Traversal traversal, final TraversalEngine traversalEngine) {
        if (engine.equals(TraversalEngine.COMPUTER))  // Gremlin OLAP does not use indices but linear scans of the graph
            return;
        final TinkerGraphStep tinkerGraphStep = (TinkerGraphStep) traversal.getSteps().get(0);
        Step currentStep = tinkerGraphStep.getNextStep();
        while (true) {
            if (currentStep == EmptyStep.instance() || TraversalHelper.isLabeled(currentStep))
                break;
            if (currentStep instanceof HasStep) {
                tinkerGraphStep.hasContainers.add(((HasStep) currentStep).hasContainer);
                TraversalHelper.removeStep(currentStep, traversal);
            } else if (currentStep instanceof IntervalStep) {
                tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).startContainer);
                tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).endContainer);
                TraversalHelper.removeStep(currentStep, traversal);
            } else if (currentStep instanceof IdentityStep) {
                // do nothing
            } else {
                break;
            }
            currentStep = currentStep.getNextStep();
        }
        tinkerGraphStep.generateHolderIterator(false);
    }
}

The traversal is redefined by simply taking a chain of `has()`-steps and `interval()`-steps after `g.V()` (`TinkerGraphStep`) and providing them to `TinkerGraphStep`. Then its up to TinkerGraphStep to determine if an appropriate index exists. In the code below, review the `vertices()` method and note how if an index exists, for a particular `HasContainer`, then that index is first queried before the remaining `HasContainer` filters are serially applied.

[source,groovy]
gremlin> t = g.V().has('name','marko'); null
==>null
gremlin> t.toString()
==>[TinkerGraphStep, HasStep([name,EQUAL,marko])]
gremlin> t.getStrategies().apply()
==>null
gremlin> t.toString()
==>[TinkerGraphStep([[name,EQUAL,marko]])]

GraphTraversalStrategyRegistry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are various default strategies that are applied to a `GraphTraversal` when it is created. However, not all these strategies are required and in fact, depending on _a priori_ knowledge of the statistics of the graph being traversed, turning off default strategies and/or activating custom strategies may prove fruitful. `GraphTraversalStrategyRegistry` is a global static class that supports the registering (and un-registering) of traversal strategies that will be applied every time a `GraphTraversal` is constructed (e.g. `DefaultGraphTraversal`).

WARNING: It is possible to create faulty traversals by modifying the `GraphTraversalStrategyRegistry`. This functionality is reserved for experts with a solid understanding of Gremlin's traversal strategy framework.

[source,groovy]
gremlin> import com.tinkerpop.gremlin.process.graph.strategy.*
...
gremlin> GraphTraversalStrategyRegistry.instance()
==>strategies[TraverserSourceStrategy, LabeledEndStepStrategy, UntilStrategy, DedupOptimizerStrategy, IdentityRemovalStrategy, SideEffectCapStrategy, MatchWhereStrategy, ChooseLinearStrategy, UnionLinearStrategy, ComparingReductionStrategy, EngineDependentStrategy]
gremlin> t = g.V().identity().identity().identity().range(0,1)
==>v[1]
==>v[2]
gremlin> t.toString()
==>[TinkerGraphStep(vertex), RangeStep(0,1)] // the identity reduction strategy removes unlabeled identity steps
gremlin> GraphTraversalStrategyRegistry.instance().unregister(IdentityRemovalStrategy)
==>null
gremlin> t = g.V().identity().identity().identity().range(0,1)
==>v[1]
==>v[2]
gremlin> t.toString()
==>[TinkerGraphStep(vertex), IdentityStep, IdentityStep, IdentityStep, RangeStep(0,1)]

Domain Specific Languages
-------------------------

CAUTION: As of TinkerPop x.y.z, the presented domain specific language framework has not been fully flushed out. Expect changes to the API until this "caution"-note is removed.

image:gremlin-quill.png[width=200,float=right] The super interface of GraphTraversal is `Traversal`. It is possible for developers to create domain specific traversals by extending Traversal. For example, a `SocialTraversal` example is provided below.

[source,java]
----
public interface SocialTraversal<S, E> extends Traversal<S, E> {

    public default SocialTraversal<S, Vertex> people() {
        return (SocialTraversal) this.addStep(new StartStep<>(this, this.sideEffects().getGraph().V().has("age")));
    }

    public default SocialTraversal<S, Vertex> people(String name) {
        return (SocialTraversal) this.addStep(new StartStep<>(this, this.sideEffects().getGraph().V().has("name", name)));
    }

    public default SocialTraversal<S, Vertex> knows() {
        final FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
        flatMapStep.setFunction(v -> v.get().out("knows"));
        return (SocialTraversal) this.addStep(flatMapStep);
    }

    public default SocialTraversal<S, Vertex> created() {
        final FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
        flatMapStep.setFunction(v -> v.get().out("created"));
        return (SocialTraversal) this.addStep(flatMapStep);
    }

    public default SocialTraversal<S, String> name() {
        MapStep<Vertex, String> mapStep = new MapStep<>(this);
        mapStep.setFunction(v -> v.get().<String>value("name"));
        return (SocialTraversal) this.addStep(mapStep);
    }

    public static <S> SocialTraversal<S, S> of(final Graph graph) {
        final SocialTraversal traversal = new DefaultSocialTraversal(graph);
        return traversal;
    }

    public class DefaultSocialTraversal extends DefaultTraversal implements SocialTraversal {
        public DefaultSocialTraversal(final Graph graph) {
            super(graph);
            this.getStrategies().register(TraverserSourceStrategy.instance());
        }
    }
}
----

This traversal definition can now be used as follows.

[source,java]
g.of(SocialTraversal.class).people("marko").knows().name()

By extending `Traversal`, users can create a DSL that is respective of the semantics of their data. Instead of querying in terms of vertices/edges/properties, they can query in terms of, for example, people, their friends, and their names.

